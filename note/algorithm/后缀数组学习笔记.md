---
layout: default
title: algorithm_note
---
# 后缀数组学习笔记
数组名称和意义
$sa[i]$:表示字典序第i的后缀的起点；$rk[i]$:表示以$i$为起点的后缀的排名，在后缀数的排名中，由于每个后缀的长度都不同，所以不会出现两个后缀排名相同的情况。
## 基数排序来求后缀数组，使用倍增的方法
有两个注意的地方，由于需要对数组的元素进行两个关键字的排序，所以可以先按照第二关键字来进行排序，在按照第一关键字来进行排序。二是基数的统计，可以借鉴稀疏矩阵的转置方法或者是图的链式前向星的存图方式，也就是一个链表的链接方式，但要注意的是使用这样的储存方式，在统计基数的时候需要从最后一个元素的位置来进行统计，因为最后遍历的元素会放在链表的首部，实际上就是链表的头插法。
代码如下；
```cpp
// 基数排序，x数组作为第一关键字，在后缀数组中，第一关键字数组为rk，第二关键字数组为rk+w，w为倍增因子，是二的幂次
// 调用两次基数排序即可，最后记得将排名去重，因为倍增的过程还没有计算出所有后缀的排名，所以可能有两个字符串片段 具有相同的排名
void cardinal_sort(int* arr,int* x,int n){
  static int head[N],nex[N];
  int mmin=INT_MAX,mmax=0, idx=0;
  for(int i=0;i<n;++i) mmin=min(mmin,x[i]),mmax=max(mmax,x[i]);
  memset(head+mmin,-1,(mmax-mmin+1)*sizeof(int));
  // 从数组后面最后一个元素开始遍历，将上一次排序次序比较大的元素放在链表的头部
  for(int i=n-1;i>=0;--i){
    int k=arr[i];
    nex[k]=head[x[k]], head[x[k]]=k;
  }
  for(int u=mmin;u<=mmax;++u) for(int i=head[u];~i;i=nex[i]) arr[idx++]=i;
}
```

## 化简第二关键字的排序（待定。。。